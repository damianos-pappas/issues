name: Project audit fields update (Org Project)

on:
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: project-audit
  cancel-in-progress: false

env:
  PROJECT_OWNER: your-enterprise-org
  PROJECT_NUMBER: 1

jobs:
  resolve-project-id:
    runs-on: ubuntu-latest
    outputs:
      project_id: ${{ steps.get_project.outputs.project_id }}
      project_title: ${{ steps.get_project.outputs.project_title }}
    steps:
      - name: Resolve org project ID
        id: get_project
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const org = process.env.PROJECT_OWNER;
            const number = Number(process.env.PROJECT_NUMBER);

            const data = await github.graphql(
              `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    title
                  }
                }
              }
              `,
              { org, number }
            );

            const project = data?.organization?.projectV2;
            if (!project?.id) {
              throw new Error(`Could not resolve projectV2 for org="${org}" number=${number}. Check org login, project number, and token permissions.`);
            }

            core.info(`Project title: ${project.title}`);
            core.info(`Project id: ${project.id}`);

            core.setOutput("project_id", project.id);
            core.setOutput("project_title", project.title);

  resolve-field-ids:
    runs-on: ubuntu-latest
    needs: [resolve-project-id]
    outputs:
      field_createdat_id: ${{ steps.resolve.outputs.field_createdat_id }}
      field_updatedat_id: ${{ steps.resolve.outputs.field_updatedat_id }}
      field_updatedattimestamp_id: ${{ steps.resolve.outputs.field_updatedattimestamp_id }}
      field_closedat_id: ${{ steps.resolve.outputs.field_closedat_id }}
    steps:
      - name: Resolve audit field IDs (Org Project)
        id: resolve
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const org = process.env.PROJECT_OWNER;
            const projectNumber = Number(process.env.PROJECT_NUMBER);

            const data = await github.graphql(
              `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    title
                    fields(first: 100) {
                      nodes {
                        __typename
                        ... on ProjectV2FieldCommon {
                          id
                          name
                          dataType
                        }
                      }
                    }
                  }
                }
              }
              `,
              { org, number: projectNumber }
            );

            const project = data.organization.projectV2;
            const fields = project.fields.nodes || [];

            const want = new Map([
              ["CreatedAt", "DATE"],
              ["UpdatedAt", "DATE"],
              ["UpdatedAtTimestamp", "TEXT"],
              ["ClosedAt", "DATE"],
            ]);

            const byName = new Map();
            for (const f of fields) {
              if (!f?.name || !f?.id) continue;
              if (want.has(f.name)) byName.set(f.name, f);
            }

            function must(name) {
              const f = byName.get(name);
              if (!f) throw new Error(`Field not found in project: "${name}"`);
              const expected = want.get(name);
              if (f.dataType !== expected) {
                throw new Error(`Field "${name}" has type ${f.dataType}, expected ${expected}`);
              }
              return f.id;
            }

            core.info(`Project title: ${project.title}`);
            core.info(`Project node id: ${project.id}`);

            core.setOutput("field_createdat_id", must("CreatedAt"));
            core.setOutput("field_updatedat_id", must("UpdatedAt"));
            core.setOutput("field_updatedattimestamp_id", must("UpdatedAtTimestamp"));
            core.setOutput("field_closedat_id", must("ClosedAt"));

  audit:
    runs-on: ubuntu-latest
    needs: [resolve-project-id, resolve-field-ids]
    steps:
      - name: Update project fields (including ClosedAt)
        uses: actions/github-script@v7
        env:
          PROJECT_ID: ${{ needs.resolve-project-id.outputs.project_id }}
          FIELD_CREATEDAT_ID: ${{ needs.resolve-field-ids.outputs.field_createdat_id }}
          FIELD_UPDATEDAT_ID: ${{ needs.resolve-field-ids.outputs.field_updatedat_id }}
          FIELD_UPDATEDATTIMESTAMP_ID: ${{ needs.resolve-field-ids.outputs.field_updatedattimestamp_id }}
          FIELD_CLOSEDAT_ID: ${{ needs.resolve-field-ids.outputs.field_closedat_id }}
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const projectId = process.env.PROJECT_ID;
            const fieldCreatedAtId = process.env.FIELD_CREATEDAT_ID;
            const fieldUpdatedAtId = process.env.FIELD_UPDATEDAT_ID;
            const fieldUpdatedAtTimestampId = process.env.FIELD_UPDATEDATTIMESTAMP_ID;
            const fieldClosedAtId = process.env.FIELD_CLOSEDAT_ID;

            if (!projectId || !fieldCreatedAtId || !fieldUpdatedAtId || !fieldUpdatedAtTimestampId || !fieldClosedAtId) {
              throw new Error("Missing PROJECT_ID or one of the FIELD_* env vars");
            }

            const utcToday = () => {
              const d = new Date();
              const yyyy = d.getUTCFullYear();
              const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
              const dd = String(d.getUTCDate()).padStart(2, "0");
              return `${yyyy}-${mm}-${dd}`; // DATE field format
            };

            const startOfTodayUtc = () => {
              const now = new Date();
              return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0));
            };

            const toUtcDateOnly = (isoString) => {
              if (!isoString) return "";
              const d = new Date(isoString);
              if (Number.isNaN(d.getTime())) return "";
              const yyyy = d.getUTCFullYear();
              const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
              const dd = String(d.getUTCDate()).padStart(2, "0");
              return `${yyyy}-${mm}-${dd}`;
            };

            async function fetchItemsPage(after) {
              return await github.graphql(
                `
                query($projectId: ID!, $after: String) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 100, after: $after) {
                        nodes {
                          id
                          createdAt
                          updatedAt
                          content {
                            __typename
                            ... on Issue {
                              id
                              state
                              closedAt
                            }
                            ... on PullRequest {
                              id
                              state
                              closedAt
                              mergedAt
                            }
                          }
                          fieldValues(first: 100) {
                            nodes {
                              __typename
                              ... on ProjectV2ItemFieldDateValue {
                                date
                                field { ... on ProjectV2FieldCommon { id name } }
                              }
                              ... on ProjectV2ItemFieldTextValue {
                                text
                                field { ... on ProjectV2FieldCommon { id name } }
                              }
                            }
                          }
                        }
                        pageInfo { hasNextPage endCursor }
                      }
                    }
                  }
                }
                `,
                { projectId, after }
              );
            }

            async function setDateField(itemId, fieldId, date) {
              await github.graphql(
                `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $date: Date!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { date: $date }
                  }) { projectV2Item { id } }
                }
                `,
                { projectId, itemId, fieldId, date }
              );
            }

            async function setTextField(itemId, fieldId, text) {
              await github.graphql(
                `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $text: String!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { text: $text }
                  }) { projectV2Item { id } }
                }
                `,
                { projectId, itemId, fieldId, text: (text ?? "").toString().slice(0, 500) }
              );
            }

            function getDateFieldValue(item, fieldId) {
              const nodes = item.fieldValues?.nodes || [];
              const n = nodes.find(x => x?.field?.id === fieldId);
              return n?.date || "";
            }

            function computeClosedDate(item) {
              const c = item.content;
              if (!c || !c.__typename) return "";

              if (c.__typename === "Issue") {
                // state: OPEN/CLOSED
                if (c.state !== "CLOSED") return "";
                return toUtcDateOnly(c.closedAt);
              }

              if (c.__typename === "PullRequest") {
                // state: OPEN/CLOSED/MERGED (MERGED still usually has closedAt)
                if (c.state !== "CLOSED" && c.state !== "MERGED") return "";
                // prefer mergedAt when present, otherwise closedAt
                return toUtcDateOnly(c.mergedAt || c.closedAt);
              }

              return "";
            }

            const today = utcToday();
            const todayStart = startOfTodayUtc();

            let after = null;
            let scanned = 0;
            let touched = 0;
            let closedSet = 0;

            while (true) {
              const data = await fetchItemsPage(after);
              const conn = data.node.items;
              const items = conn.nodes || [];

              for (const item of items) {
                scanned++;

                // Only touch items updated today (UTC).
                // Closing an issue/PR updates it, so this also catches "closed today" items.
                const itemUpdatedAt = new Date(item.updatedAt);
                if (itemUpdatedAt < todayStart) continue;

                // CreatedAt: set once (if blank)
                const createdVal = getDateFieldValue(item, fieldCreatedAtId);
                if (!createdVal) {
                  await setDateField(item.id, fieldCreatedAtId, today);
                }

                // UpdatedAt: set every time we touch it
                await setDateField(item.id, fieldUpdatedAtId, today);

                // UpdatedAtTimestamp: set every time we touch it
                await setTextField(
                  item.id,
                  fieldUpdatedAtTimestampId,
                  new Date().toISOString().slice(0, 16).replace("T", " ")
                );

                // ClosedAt: set only when the linked content is closed/merged and field is currently blank
                const existingClosed = getDateFieldValue(item, fieldClosedAtId);
                if (!existingClosed) {
                  const closedDate = computeClosedDate(item);
                  if (closedDate) {
                    await setDateField(item.id, fieldClosedAtId, closedDate);
                    closedSet++;
                  }
                }

                touched++;
              }

              if (!conn.pageInfo.hasNextPage) break;
              after = conn.pageInfo.endCursor;
            }

            core.info(`Scanned ${scanned} items. Touched ${touched} items (updated since ${today} UTC). Set ClosedAt on ${closedSet} items.`);
