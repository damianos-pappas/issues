name: Roll up parent Start/End from sub-issues (max depth)

on:
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: rollup-parent-dates
  cancel-in-progress: false

env:
  PROJECT_OWNER: damianos-pappas
  PROJECT_NUMBER: 1
  FIELD_START_DATE_NAME: "Start Date"
  FIELD_END_DATE_NAME: "End Date"

jobs:
  resolve-project-id:
    runs-on: ubuntu-latest
    outputs:
      project_id: ${{ steps.get_project_id.outputs.project-id }}
    steps:
      - name: Get Project ID
        id: get_project_id
        uses: monry/actions-get-project-id@v2
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          project-owner: ${{ env.PROJECT_OWNER }}
          project-number: ${{ env.PROJECT_NUMBER }}

  resolve-field-ids:
    runs-on: ubuntu-latest
    needs: [resolve-project-id]
    outputs:
      field_start_id: ${{ steps.resolve.outputs.field_start_id }}
      field_end_id: ${{ steps.resolve.outputs.field_end_id }}
    steps:
      - name: Resolve Start/End field IDs
        id: resolve
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const owner = process.env.PROJECT_OWNER;
            const projectNumber = Number(process.env.PROJECT_NUMBER);
            const startName = process.env.FIELD_START_DATE_NAME;
            const endName = process.env.FIELD_END_DATE_NAME;

            const data = await github.graphql(
              `
              query($login: String!, $number: Int!) {
                user(login: $login) {
                  projectV2(number: $number) {
                    id
                    title
                    fields(first: 100) {
                      nodes {
                        __typename
                        ... on ProjectV2FieldCommon {
                          id
                          name
                          dataType
                        }
                      }
                    }
                  }
                }
              }
              `,
              { login: owner, number: projectNumber }
            );

            const fields = data.user.projectV2.fields.nodes || [];

            function findDateFieldId(name) {
              const f = fields.find(x => x?.name === name);
              if (!f) throw new Error(`Field not found: "${name}"`);
              if (f.dataType !== "DATE") throw new Error(`Field "${name}" is ${f.dataType}, expected DATE`);
              return f.id;
            }

            core.setOutput("field_start_id", findDateFieldId(startName));
            core.setOutput("field_end_id", findDateFieldId(endName));

  rollup:
    runs-on: ubuntu-latest
    needs: [resolve-project-id, resolve-field-ids]
    steps:
      - name: Roll up parent dates (cascade up to max depth)
        uses: actions/github-script@v7
        env:
          PROJECT_ID: ${{ needs.resolve-project-id.outputs.project_id }}
          FIELD_START_ID: ${{ needs.resolve-field-ids.outputs.field_start_id }}
          FIELD_END_ID: ${{ needs.resolve-field-ids.outputs.field_end_id }}
        with:
          github-token: ${{ secrets.PROJECT_PAT }}
          script: |
            const projectId = process.env.PROJECT_ID;
            const fieldStartId = process.env.FIELD_START_ID;
            const fieldEndId = process.env.FIELD_END_ID;

            // Change this if you want deeper rollups later
            const MAX_LEVELS_UP = 3;

            if (!projectId || !fieldStartId || !fieldEndId) {
              throw new Error("Missing PROJECT_ID / FIELD_START_ID / FIELD_END_ID");
            }

            // last 24h window
            const now = new Date();
            const since = new Date(now.getTime() - 24 * 60 * 60 * 1000);

            const parseYmd = (s) => (s ? new Date(`${s}T00:00:00Z`) : null);
            const ymd = (d) => {
              const yyyy = d.getUTCFullYear();
              const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
              const dd = String(d.getUTCDate()).padStart(2, "0");
              return `${yyyy}-${mm}-${dd}`;
            };

            async function setDateField(itemId, fieldId, dateStr) {
              await github.graphql(
                `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $date: Date!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { date: $date }
                  }) { projectV2Item { id } }
                }
                `,
                { projectId, itemId, fieldId, date: dateStr }
              );
            }

            async function fetchItemsPage(after) {
              return await github.graphql(
                `
                query($projectId: ID!, $after: String) {
                  node(id: $projectId) {
                    ... on ProjectV2 {
                      items(first: 100, after: $after) {
                        nodes {
                          id
                          updatedAt
                          content {
                            __typename
                            ... on Issue {
                              id
                              number
                              repository { nameWithOwner }
                            }
                          }
                          fieldValues(first: 50) {
                            nodes {
                              __typename
                              ... on ProjectV2ItemFieldDateValue {
                                date
                                field { ... on ProjectV2FieldCommon { id name } }
                              }
                            }
                          }
                        }
                        pageInfo { hasNextPage endCursor }
                      }
                    }
                  }
                }
                `,
                { projectId, after }
              );
            }

            function getDateValue(item, wantedFieldId) {
              const nodes = item.fieldValues?.nodes || [];
              const n = nodes.find(v => v?.field?.id === wantedFieldId);
              return n?.date || "";
            }

            // Index issues-in-project by GraphQL node id
            const issueIndex = new Map(); // issueNodeId -> { projectItemId, repoFullName, number, start, end, updatedAt }
            const changedIssues = [];

            let after = null;
            while (true) {
              const data = await fetchItemsPage(after);
              const conn = data.node.items;
              const items = conn.nodes || [];

              for (const item of items) {
                if (item.content?.__typename !== "Issue") continue;

                const issueId = item.content.id;
                const start = getDateValue(item, fieldStartId);
                const end = getDateValue(item, fieldEndId);

                issueIndex.set(issueId, {
                  projectItemId: item.id,
                  repoFullName: item.content.repository.nameWithOwner,
                  number: item.content.number,
                  start,
                  end,
                  updatedAt: item.updatedAt,
                });

                if (new Date(item.updatedAt) >= since) changedIssues.push(issueId);
              }

              if (!conn.pageInfo.hasNextPage) break;
              after = conn.pageInfo.endCursor;
            }

            const uniqueChanged = [...new Set(changedIssues)];
            core.info(`Changed issues in last 24h: ${uniqueChanged.length}`);

            // REST helpers for sub-issues hierarchy
            async function getParentIssue(repoFullName, issueNumber) {
              const [owner, repo] = repoFullName.split("/");
              try {
                const res = await github.request("GET /repos/{owner}/{repo}/issues/{issue_number}/parent", {
                  owner,
                  repo,
                  issue_number: issueNumber,
                  headers: { "X-GitHub-Api-Version": "2022-11-28" },
                });
                return res.data; // includes node_id + number
              } catch (e) {
                if (e.status === 404) return null; // no parent
                throw e;
              }
            }

            async function listSubIssues(repoFullName, parentNumber) {
              const [owner, repo] = repoFullName.split("/");
              const all = [];
              let page = 1;

              while (true) {
                const res = await github.request("GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues", {
                  owner,
                  repo,
                  issue_number: parentNumber,
                  per_page: 100,
                  page,
                  headers: { "X-GitHub-Api-Version": "2022-11-28" },
                });

                const items = res.data || [];
                all.push(...items);

                if (items.length < 100) break;
                page++;
              }

              return all;
            }

            // Recalc a single parent based on its children (that are in the project)
            async function recalcAndUpdateParent(parentNodeId, repoFullName, parentNumber) {
              const parentInProject = issueIndex.get(parentNodeId);
              if (!parentInProject) {
                core.info(`Parent ${repoFullName}#${parentNumber} not in project; skip.`);
                return false;
              }

              const subs = await listSubIssues(repoFullName, parentNumber);

              const starts = [];
              const ends = [];

              for (const si of subs) {
                const childNodeId = si.node_id;
                const childInProject = issueIndex.get(childNodeId);
                if (!childInProject) continue;

                const s = parseYmd(childInProject.start);
                const e = parseYmd(childInProject.end);
                if (s) starts.push(s.getTime());
                if (e) ends.push(e.getTime());
              }

              if (!starts.length && !ends.length) {
                core.info(`No child dates (in project) for parent ${repoFullName}#${parentNumber}; skip.`);
                return false;
              }

              const minStart = starts.length ? new Date(Math.min(...starts)) : null;
              const maxEnd = ends.length ? new Date(Math.max(...ends)) : null;

              if (minStart) await setDateField(parentInProject.projectItemId, fieldStartId, ymd(minStart));
              if (maxEnd) await setDateField(parentInProject.projectItemId, fieldEndId, ymd(maxEnd));

              core.info(`Updated parent ${repoFullName}#${parentNumber}: Start=${minStart ? ymd(minStart) : "(unchanged)"} End=${maxEnd ? ymd(maxEnd) : "(unchanged)"}`);
              return true;
            }

            // Cascade upward up to MAX_LEVELS_UP
            const visitedParents = new Set(); // avoid repeating same parent
            let updatedParents = 0;

            for (const childNodeId of uniqueChanged) {
              let currentNodeId = childNodeId;

              for (let level = 1; level <= MAX_LEVELS_UP; level++) {
                const current = issueIndex.get(currentNodeId);
                if (!current) break;

                const parent = await getParentIssue(current.repoFullName, current.number);
                if (!parent) break;

                const parentNodeId = parent.node_id;
                const parentKey = `${parentNodeId}`;

                // Prevent infinite loops / repeated recalcs
                if (visitedParents.has(parentKey)) {
                  currentNodeId = parentNodeId; // still move up for next level
                  continue;
                }
                visitedParents.add(parentKey);

                const didUpdate = await recalcAndUpdateParent(parentNodeId, current.repoFullName, parent.number);
                if (didUpdate) updatedParents++;

                // Move up
                currentNodeId = parentNodeId;
              }
            }

            core.info(`Done. Updated ${updatedParents} parents (unique=${visitedParents.size}), max levels up=${MAX_LEVELS_UP}.`);